/*
 * @lc app=leetcode id=37 lang=javascript
 *
 * [37] Sudoku Solver
 */

// @lc code=start
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {
    const bucketIndexes = new Map();
    bucketIndexes.set(1, { 0: [0, 1, 2], 1: [0, 1, 2], 2: [0, 1, 2] });
    bucketIndexes.set(2, { 0: [3, 4, 5], 1: [3, 4, 5], 2: [3, 4, 5] });
    bucketIndexes.set(3, { 0: [6, 7, 8], 1: [6, 7, 8], 2: [6, 7, 8] });
    bucketIndexes.set(4, { 3: [0, 1, 2], 4: [0, 1, 2], 5: [0, 1, 2] });
    bucketIndexes.set(5, { 3: [3, 4, 5], 4: [3, 4, 5], 5: [3, 4, 5] });
    bucketIndexes.set(6, { 3: [6, 7, 8], 4: [6, 7, 8], 5: [6, 7, 8] });
    bucketIndexes.set(7, { 6: [0, 1, 2], 7: [0, 1, 2], 8: [0, 1, 2] });
    bucketIndexes.set(8, { 6: [3, 4, 5], 7: [3, 4, 5], 8: [3, 4, 5] });
    bucketIndexes.set(9, { 6: [6, 7, 8], 7: [6, 7, 8], 8: [6, 7, 8] });
    let bucketNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    let NumbersProcessed = [];
    let ignoreList = new Map();
    let ignoreBucketNumber = new Map();
    let numberToBeChecked = new Map();
    let backTracking = false;
    const toNumbers = arr => arr.map(Number);
    let pbucket = [];
    for (const [key, value] of bucketIndexes) {
      let obj = value;
      for (const i in obj) {
        if (obj.hasOwnProperty(i)) {
          for (j = 0; j < 3; j++) {
            if (board[i][obj[i][j]] != ".") {
              ToAddIgnoreList("B", board[i][obj[i][j]], key);
            }
 
            if (
              board[i][obj[i][j]] != "." &&
              NumbersProcessed.indexOf(board[i][obj[i][j]]) == -1
            ) {
              NumbersProcessed.push(board[i][obj[i][j]]);
              numberToBeChecked.set(board[i][obj[i][j]], board[i][obj[i][j]]);
              ToAddIgnoreList("RN", board[i][obj[i][j]], key, i, obj[i][j]);
 
              for (let k = 1; k <= 9; k++) {
                if (k == key) continue;
                else {
                  let objBucketIndexes = bucketIndexes.get(k);
                  for (const kk in objBucketIndexes) {
                    if (objBucketIndexes.hasOwnProperty(kk)) {
                      for (let col = 0; col < 3; col++) {
                        if (
                          board[i][obj[i][j]] ==
                          board[kk][objBucketIndexes[kk][col]]
                        ) {
                          ToAddIgnoreList(
                            "RN",
                            board[i][obj[i][j]],
                            key,
                            kk,
                            objBucketIndexes[kk][col]
                          );
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    checkNumber();
    //console.log(board)  
    backTrack();
    console.log(board)
     
  function backTrack() {
      backTracking = true;
      function forcefullySetVal(possibleNumberList,val,rw,cl) {
          board[rw][cl] = String(val);
          let bi = getBucketIndex(rw,cl);
          //console.log(rw +'--' + cl + '--' + val + '--' + bi);
          let data = new Map();
          data.set('B',bi);
          data.set('RW',rw);
          data.set('CL',cl);
          data.set('NM',[val]);
          removalFromPossibilityMatrix(possibleNumberList,'HS',data);
          ToAddIgnoreList("B", val , bi);
          ToAddIgnoreList(
              "RN",
              val,
              bi,
              rw,
              cl
          );
      }
      function isCompleteBoard() {
        let isCompleteBoard = true;
        for(let i = 0;i < board.length;i++) {
         
          if(['1','2','3','4','5','6','7','8','9'].filter(value => board[i].includes(value)).length != 9){
            isCompleteBoard = false;
            break;
          }
        }
        return isCompleteBoard;
      }
     
      let sbucket = JSON.parse(JSON.stringify(pbucket));
      let sboard  = JSON.parse(JSON.stringify(board));
     
      let signoreBucketNumber  = new Map(JSON.parse(
        JSON.stringify(Array.from(ignoreBucketNumber))
      ));
      let signoreList  = new Map(JSON.parse(
        JSON.stringify(Array.from(ignoreList))
      ));
      let sortedPM = new Map();
      for(let i=0;i < pbucket.length;i++){
        for(let j = 0; j < pbucket[i].length;j++) {
          if(pbucket[i][j].length != 0) {
            for(let k = 0; k < pbucket[i][j].length;k++){
              let fkey = pbucket[i][j].length;
              let skey = `${i}`+`${j}`;
              let val = pbucket[i][j][k];
              //console.log(skey);
              if (sortedPM.has(parseInt(fkey))) {
                if(sortedPM.get(parseInt(fkey)).has(skey))
                   sortedPM.get(parseInt(fkey)).get(skey).push(parseInt(val));
                else
                  sortedPM.get(parseInt(fkey)).set(String(skey),[val]);
              } else {
                  sortedPM.set(parseInt(fkey),
                  new Map());
                  sortedPM.get(parseInt(fkey)).set(String(skey),[val]);
              }
            }
          }
        }
      }
     
      sortedPM = new Map([...sortedPM].sort());
     
      let isComplete = false;
      for (const [key, value] of sortedPM) {
        if(isComplete) break;
       
        let objMap = value;
        for (const [k1, v1] of objMap) {
          if(isComplete)
            break;
         
          for(let i = 0;i < v1.length;i++){
             
            let rowIndex = String(k1).slice(0, 1);
            let colIndex = String(k1).slice(1, 2);
            forcefullySetVal(pbucket,parseInt(v1[i]),rowIndex,colIndex);
                    kv = [];
                    kv.push([parseInt(v1[i]),parseInt(v1[i])]);
                    numberToBeChecked = new Map(kv);
                    checkNumber();
            if(isCompleteBoard()) {
              isComplete= true;
              console.log('Completed');
              //pbucket = [];
              //ignoreBucketNumber = new Map();
              //ignoreList = new Map();
             
              break;
               
            } else {

              pbucket = JSON.parse(JSON.stringify(sbucket));
              board  = JSON.parse(JSON.stringify(sboard));
             
              ignoreBucketNumber  = new Map(JSON.parse(
                JSON.stringify(Array.from(signoreBucketNumber))
              ));
              ignoreList  = new Map(JSON.parse(
                JSON.stringify(Array.from(signoreList))
              ));
             
            }
          }
        }
      }  
    }
    //console.log(pbucket);
    //return board;
    function checkNumber() {
      let kvArray = [];
      let blnMatch = false;
 
      function logMapElements(value, key, map) {
        let selBucketNumber;
 
        ib = value;
        selBucketNumber = ib;
        for (let k = 1; k <= 9; k++) {
          let noOfBlankBoxesInBucket = 0;
          let selRowNumber = 0;
          let selColumnNumber = 0;
          if(ignoreBucketNumber.has(ib)) {

            if (ignoreBucketNumber.get(ib).indexOf(k) == -1) {
                        let objBucketIndexes = bucketIndexes.get(k);
             
                        for (let kk in objBucketIndexes) {
                          if (
                            objBucketIndexes.hasOwnProperty(kk) &&
                            ignoreList.hasOwnProperty(ib) &&  
                            ignoreList.get(ib).Row.indexOf(parseInt(kk)) == -1
                          ) {
                            for (let coli in objBucketIndexes[kk]) {
                              if (
                                ignoreList
                                  .get(ib)
                                  .Col.indexOf(parseInt(objBucketIndexes[kk][coli])) == -1
                              ) {
                                if (board[kk][objBucketIndexes[kk][coli]] == ".") {
                                  noOfBlankBoxesInBucket++;
                                  selRowNumber = kk;
                                  selColumnNumber = objBucketIndexes[kk][coli];
                                }
                              }
                            }
                          }
                        }
             
                        if (noOfBlankBoxesInBucket == 1) {
                          blnMatch = true;  
                          //console.log("H "+selRowNumber+' '+ selColumnNumber + ' ' + ib);
                          board[selRowNumber][selColumnNumber] = ib;
                          kvArray.push([ib, ib]);
                          ToAddIgnoreList("B", ib, k);
                          ToAddIgnoreList("RN", ib, k, selRowNumber, selColumnNumber);
                        }
                      }
          }
         
        }
      }
      function getBucketIndex(rowNum, colNum) {
        for (const [key, value] of bucketIndexes) {
          let obj = value;
          for (const i in obj) {
            if (obj.hasOwnProperty(i)) {
              if (i == rowNum && obj[i].indexOf(colNum) != -1) {
                return key;
              }
            }
          }
        }
      }
      function AddOneMissingNumber() {
        for (let k = 1; k <= 9; k++) {
          let objBucketIndexes = bucketIndexes.get(k);
          let myMap = new Map([
            [1, 1],
            [2, 2],
            [3, 3],
            [4, 4],
            [5, 5],
            [6, 6],
            [7, 7],
            [8, 8],
            [9, 9],
          ]);
          let oneRemainingRowNumber = 0;
          let oneRemainingColNumber = 0;
          for (let kk in objBucketIndexes) {
            for (let coli in objBucketIndexes[kk]) {
              if (board[kk][objBucketIndexes[kk][coli]] != ".") {
                myMap.delete(parseInt(board[kk][objBucketIndexes[kk][coli]]));
              } else {
                oneRemainingRowNumber = kk;
                oneRemainingColNumber = objBucketIndexes[kk][coli];
              }
            }
          }
          if (myMap.size == 1) {
            let ib = `${Array.from(myMap).pop()[1]}`;
            board[oneRemainingRowNumber][oneRemainingColNumber] = ib;
            if(kvArray.filter(value => [String(ib)].includes(value[0])).length == 0)
            kvArray.push([ib, ib]);
            ToAddIgnoreList("B", ib, k);
            ToAddIgnoreList(
              "RN",
              ib,
              k,
              oneRemainingRowNumber,
              oneRemainingColNumber
            );
          }
        }
        for (let i = 0; i < 9; i++) {
          let myMap = new Map([
            [1, 1],
            [2, 2],
            [3, 3],
            [4, 4],
            [5, 5],
            [6, 6],
            [7, 7],
            [8, 8],
            [9, 9],
          ]);
          let oneRemainingRowNumber = 0;
          let oneRemainingColNumber = 0;
 
          for (let j = 0; j < 9; j++) {
            if (board[i][j] != ".") {
              myMap.delete(parseInt(board[i][j]));
            } else {
              oneRemainingRowNumber = i;
              oneRemainingColNumber = j;
            }
          }
          if (myMap.size == 1) {
            let ib = `${Array.from(myMap).pop()[1]}`;
            board[oneRemainingRowNumber][oneRemainingColNumber] = ib;
            let k = getBucketIndex(oneRemainingRowNumber, oneRemainingColNumber);
            if(kvArray.filter(value => [String(ib)].includes(value[0])).length == 0)
            kvArray.push([ib, ib]);
            ToAddIgnoreList("B", ib, k);
            ToAddIgnoreList(
              "RN",
              ib,
              k,
              oneRemainingRowNumber,
              oneRemainingColNumber
            );
          }
        }
 
        for (let i = 0; i < 9; i++) {
          let myMap = new Map([
            [1, 1],
            [2, 2],
            [3, 3],
            [4, 4],
            [5, 5],
            [6, 6],
            [7, 7],
            [8, 8],
            [9, 9],
          ]);
          let oneRemainingRowNumber = 0;
          let oneRemainingColNumber = 0;
 
          for (let j = 0; j < 9; j++) {
            if (board[j][i] != ".") {
              myMap.delete(parseInt(board[j][i]));
            } else {
              oneRemainingRowNumber = j;
              oneRemainingColNumber = i;
            }
          }
          if (myMap.size == 1) {
            let ib = `${Array.from(myMap).pop()[1]}`;
            let k = getBucketIndex(oneRemainingRowNumber, oneRemainingColNumber);
 
            board[oneRemainingRowNumber][oneRemainingColNumber] = ib;
            if(kvArray.filter(value => [String(ib)].includes(value[0])).length == 0)
            kvArray.push([ib, ib]);
            ToAddIgnoreList("B", ib, k);
            ToAddIgnoreList(
              "RN",
              ib,
              k,
              oneRemainingRowNumber,
              oneRemainingColNumber
            );
          }
        }
      }
       
      function getPossibleNumberList() {
         
          let numbersInBucketRCB = new Map([['R',new Map()],['C',new Map()],['B',new Map()]]);
     
          for (let k = 1; k <= 9; k++) {
              let objBucketIndexes = bucketIndexes.get(k);
              for (let kk in objBucketIndexes) {
                if (objBucketIndexes.hasOwnProperty(kk)) {
                  for (let coli in objBucketIndexes[kk]) {                  
                      if (board[kk][objBucketIndexes[kk][coli]] != ".") {                      
                        let selRowNumber = kk;
                        let selColumnNumber = objBucketIndexes[kk][coli];
                        if(numbersInBucketRCB.get('R').size > 0) {
                            if(!numbersInBucketRCB.get('R').has(kk)) {
                              numbersInBucketRCB.get('R').set(parseInt(kk),toNumbers(board[selRowNumber].filter((x) => {return x != '.'})))      
                            }
                        } else {
                          numbersInBucketRCB.set('R',new Map([[parseInt(kk),toNumbers(board[selRowNumber].filter((x) => {return x != '.'}))   ]]));  
                        }
 
                        if(numbersInBucketRCB.get('C').size > 0) {
                            if(!numbersInBucketRCB.get('C').has(selColumnNumber)) {
                              numbersInBucketRCB.get('C').set(selColumnNumber,[  parseInt(board[kk][objBucketIndexes[kk][coli]])  ])      
                            }
                            else {
                                numbersInBucketRCB.get('C').get(selColumnNumber).push( parseInt( board[kk][objBucketIndexes[kk][coli]] ) );
                            }
                        } else {
                          numbersInBucketRCB.set('C',new Map([[selColumnNumber,[ parseInt(board[kk][objBucketIndexes[kk][coli]])  ]]]));  
                        }  
 
                        if(numbersInBucketRCB.get('B').size > 0) {
                            if(!numbersInBucketRCB.get('B').has(k)) {
                              numbersInBucketRCB.get('B').set(k,[ parseInt(board[kk][objBucketIndexes[kk][coli]])  ])      
                            }
                            else {
                                numbersInBucketRCB.get('B').get(k).push( parseInt( board[kk][objBucketIndexes[kk][coli]]) );
                            }
                        } else {
                          numbersInBucketRCB.set('B',new Map([[k,[ parseInt(board[kk][objBucketIndexes[kk][coli]])  ]]]));  
                        }
                      }
                  }
                }
              }
      }
         
          let pboard = [];
          for(let i=0;i<9;i++) {
              pboard[i] = [];  
              for(let j =0;j<9;j++) {
                  if (board[i][j] == ".") {
                      let b = getBucketIndex(i,j);
                      let rcb;
                     
                      if(numbersInBucketRCB.get('R').has(i))
                        rcb = numbersInBucketRCB.get('R').get(i);
                       else
                        rcb = [];

                      if(numbersInBucketRCB.get('C').has(j))
                        rcb = rcb.concat(numbersInBucketRCB.get('C').get(j));
                     
                      if(numbersInBucketRCB.get('B').has(b))
                        rcb = rcb.concat(numbersInBucketRCB.get('B').get(b));  
                     
                      pboard[i][j] =  [1,2,3,4,5,6,7,8,9].filter(value => !rcb.includes(value));
 
                  } else {
                      pboard[i][j] = [];    
                  }
              }
          }
          return pboard;
      }
        /*
        nhType
          H - Hidden
          N - Naked
        rcbType
          R - Row
          C - Column
          B - Bucket
        */
      function findHiddenSDT(possibleNumberList,flag, nhType, rcbType) {
     
          let possibleNumberPosition = new Map();
     
        if(
              (nhType == 'H' && rcbType == 'R')
              || (nhType == 'H' && rcbType == 'C')            
            ) {
        for(let i = 0; i < possibleNumberList.length;i++) {
          for(let j = 0; j < possibleNumberList[i].length;j++) {          
            for(let k = 0; k < possibleNumberList[i][j].length;k++) {  
              let pKey, pSKey, pVal;
              if(nhType == 'H' && rcbType == 'R') {
              pKey = i;
              pSKey = possibleNumberList[i][j][k];
              pVal = j;
              } else if(nhType == 'H' && rcbType == 'C'){
              pKey = j;
              pSKey = possibleNumberList[i][j][k];
              pVal = i
              }
            
              if(possibleNumberPosition.has(pKey)) {
                if(possibleNumberPosition.get(pKey).has(pSKey)) {
                  possibleNumberPosition.get(pKey).get(pSKey).push(pVal);
                } else {
                  possibleNumberPosition.get(pKey).set(pSKey, [pVal])
                }
              } else {
                possibleNumberPosition.set(pKey, new Map([[pSKey, [pVal]]]));
              }
            }
          }
        }
      } else {
          for (let [key, value] of bucketIndexes) {
             
          let obj = value;
          for (let i in obj) {
            if (obj.hasOwnProperty(i)) {
              for (let j = 0; j < 3; j++) {
                for(let k = 0; k < possibleNumberList[i][obj[i][j]].length;k++) {  
                  let pKey, pSKey, pVal;
                  if(nhType == 'H' && rcbType == 'B'){
                  pKey = key;
                  pSKey = possibleNumberList[i][obj[i][j]][k];
                  pVal = `${i}`+`${obj[i][j]}`;                                  
                  } else if(nhType == 'N' && rcbType == 'R'){
                  pKey = i;
                  pSKey = `${i}`+`${obj[i][j]}`;
                  pVal = possibleNumberList[i][obj[i][j]][k];
                  } else if(nhType == 'N' && rcbType == 'C'){
                  pKey = obj[i][j];
                  pSKey = `${i}`+`${obj[i][j]}`;
                  pVal = possibleNumberList[i][obj[i][j]][k];
                  } else if(nhType == 'N' && rcbType == 'B'){
                  pKey = key;
                  pSKey = `${i}`+`${obj[i][j]}`;
                  pVal = possibleNumberList[i][obj[i][j]][k];
                  }
                
                  if(possibleNumberPosition.has(pKey)) {
                    if(possibleNumberPosition.get(pKey).has(pSKey)) {
                      possibleNumberPosition.get(pKey).get(pSKey).push(pVal);
                    } else {
                      possibleNumberPosition.get(pKey).set(pSKey, [pVal])
                    }
                  } else {
                    possibleNumberPosition.set(pKey, new Map([[pSKey, [pVal]]]));
                  }
                }
              }
            }
          }
          }
        }
        let clonedMap = new Map(possibleNumberPosition)
          for (let [key, value] of clonedMap) {
              let obj = value;
              for (let [k, v] of obj) {
                 
                  if(flag == 1) {
                      if(v.length != 1) {  //For Single
                          clonedMap.get(key).delete(k);
                      }
                  } else if(flag == 2) {
                      if(v.length != 2) {  //For Doubles
                          clonedMap.get(key).delete(k);
                      }                    
                  } else if(flag == 3) {
                      if(v.length != 2 && v.length != 3) { //For Triplets
                          clonedMap.get(key).delete(k);
                      }
                  }
              }
          }  
      let titles;
         
        if(nhType == 'H' && rcbType == 'R') {
        titles = ["Row","Columns"];
        } else if(nhType == 'H' && rcbType == 'C'){
        titles = ["Column","Rows"]
        } else if(nhType == 'H' && rcbType == 'B'){
        titles = ["Bucket","RowColumn"]
        } else if(nhType == 'N' && rcbType == 'R'){
        titles = ["Row","RowColumn"];
        } else if(nhType == 'N' && rcbType == 'C'){
        titles = ["Column","RowColumn"]
        } else if(nhType == 'N' && rcbType == 'B'){
        titles = ["Bucket","RowColumn"]
        }
 
          let difference;
          let kh = [];
          for (let [key, value] of clonedMap) {
              let obj = value;
              if(flag == 1) {
                  if(obj.size > 0) {
                      let arr = Array.from(obj, ([k, v]) => {
                                return {[k]: v};
                      });
                      //console.log(nhType + " Singles By "+titles[0]+" >> "+titles[0]+" Number => " + key + " | Numbers => "+ Object.keys(arr[0])[0]  + "  | "+titles[1]+" => " + Object.values(arr[0])[0]);
                     
                      let data = new Map();
                      if(nhType == 'H' && rcbType == 'C') {
                          board[parseInt(Object.values(arr[0])[0][0])][key] = Object.keys(arr[0])[0];
                          let bi = getBucketIndex(Object.values(arr[0])[0][0],key);
                          data.set('B',bi);
                          data.set('RW',Object.values(arr[0])[0][0]);
                          data.set('CL',key);
                          data.set('NM',[parseInt(Object.keys(arr[0])[0])]);
                          ToAddIgnoreList("B", parseInt(Object.keys(arr[0])[0]) , bi);
                          ToAddIgnoreList(
                              "RN",
                              parseInt(Object.keys(arr[0])[0]),
                              bi,
                              Object.values(arr[0])[0][0],
                              key
                            );
                      } else if(nhType == 'H' && rcbType == 'R') {
                          board[key][Object.values(arr[0])[0][0]] = Object.keys(arr[0])[0];
                          let bi = getBucketIndex(key,Object.values(arr[0])[0][0]);
                          data.set('B',bi);
                          data.set('RW',key);
                          data.set('CL',Object.values(arr[0])[0][0]);
                          data.set('NM',[parseInt(Object.keys(arr[0])[0])]);
                         
                          ToAddIgnoreList("B", parseInt(Object.keys(arr[0])[0]) , bi);
                         
                          ToAddIgnoreList(
                              "RN",
                              parseInt(Object.keys(arr[0])[0]),
                              bi,
                              key,
                              Object.values(arr[0])[0][0]
                            );
                      } else if(nhType == 'H' && rcbType == 'B') {
                          board[parseInt(String(Object.values(arr[0])[0]).slice(0, 1))][parseInt(String(Object.values(arr[0])[0]).slice(1, 2))] = Object.keys(arr[0])[0];
                          //console.log("i ==>" + String(Object.values(arr[0])[0]).slice(0, 1) +  " j =>" + String(Object.values(arr[0])[0]).slice(1, 2) + " Num => "+ Object.keys(arr[0])[0]);
                          data.set('B',key);
                          data.set('RW',parseInt(String(Object.values(arr[0])[0]).slice(0, 1)));
                          data.set('CL',parseInt(String(Object.values(arr[0])[0]).slice(1, 2)));
                          data.set('NM',[parseInt(Object.keys(arr[0])[0])]);
                          ToAddIgnoreList("B", parseInt(Object.keys(arr[0])[0]) , key);
                          ToAddIgnoreList(
                              "RN",
                              parseInt(Object.keys(arr[0])[0]),
                              key,
                              parseInt(String(Object.values(arr[0])[0]).slice(0, 1)),
                              parseInt(String(Object.values(arr[0])[0]).slice(1, 2))
                            );
                      }
                      removalFromPossibilityMatrix(possibleNumberList,'HS',data);
                      if(!kh.includes(parseInt(Object.keys(arr[0])[0])))
                          kh.push(parseInt(Object.keys(arr[0])[0]));
                  }
                 
              } else if(flag == 2) {
                  let arr = Array.from(obj, ([k, v]) => {
                                return {[k]: v};
                      });
                  for(i = 0; i<arr.length-1;i++) {
                      for(j=i+1;j<arr.length;j++ ) {            
                          let a4 = Object.values(arr[i])[0].concat(Object.values(arr[j])[0]);
                          a4 = a4.filter((item,index)=>{
                             return (a4.indexOf(item) == index)
                          });
                          if(a4.length == 2) {
                              //console.log(nhType + " Doubles By  "+titles[0]+" >> "+titles[0]+" Number => " + key + " | Numbers => "+ Object.keys(arr[i])[0] + ' - ' + Object.keys(arr[j])[0]  + " | "+titles[1]+" => " + Object.values(a4));
                              let data = new Map();
                              if(nhType == 'H' && rcbType == 'C') {
                                  data.set('CE',[[Object.values(a4)[0],key],[Object.values(a4)[1],key]]);
                                  data.set('NM',[parseInt(Object.keys(arr[i])[0]),parseInt(Object.keys(arr[j])[0])]);
                              } else if(nhType == 'H' && rcbType == 'R') {
                                  data.set('CE',[
                                                  [key,Object.values(a4)[0]],
                                                  [key,Object.values(a4)[1]]
                                                  ]);
                                  data.set('NM',[parseInt(Object.keys(arr[i])[0]),parseInt(Object.keys(arr[j])[0])]);
                              } else if(nhType == 'H' && rcbType == 'B') {
                                  data.set('CE',[
                                                  [
                                                      parseInt(String(Object.values(a4)[0]).slice(0, 1)),
                                                      parseInt(String(Object.values(a4)[0]).slice(1, 2))
                                                  ],
                                                  [
                                                      parseInt(String(Object.values(a4)[1]).slice(0, 1)),
                                                      parseInt(String(Object.values(a4)[1]).slice(1, 2))
                                                  ]                                                
                                                ]);
                                  data.set('NM',[parseInt(Object.keys(arr[i])[0]),parseInt(Object.keys(arr[j])[0])]);
                              } else if(nhType == 'N' && rcbType == 'C'){
                                data.set('CL',key);
                                data.set('IGCL',[
                                                  [
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))
                                                  ],
                                                  [
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))
                                                  ]                                                
                                                ]);
                                  data.set('NM',[parseInt(Object.values(a4)[0]),parseInt(Object.values(a4)[1])]);        
                              } else if(nhType == 'N' && rcbType == 'R'){
                                  data.set('RW',key);
                                  data.set('IGCL',[
                                                  [
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))
                                                  ],
                                                  [
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))
                                                  ]                                                
                                                ]);
                                  data.set('NM',[parseInt(Object.values(a4)[0]),parseInt(Object.values(a4)[1])]);
                                 
                              } else if(nhType == 'N' && rcbType == 'B'){
                                  data.set('BK',key);
                                  data.set('IGCL',[
                                                  [
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))
                                                  ],
                                                  [
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))
                                                  ]                                                
                                                ]);
                                  data.set('NM',[parseInt(Object.values(a4)[0]),parseInt(Object.values(a4)[1])]);      
                              }
                              if(nhType == 'H')
                                  removalFromPossibilityMatrix(possibleNumberList,'HD',data);
                              else
                                  removalFromPossibilityMatrix(possibleNumberList,'ND',data);
                                 
                          }
                      }
                  }
                 
              } else if(flag == 3) {
                 
                  let arr = Array.from(obj, ([k, v]) => {
                                return {[k]: v};
                      });
                  //console.log(arr);
                  for(i = 0; i<arr.length-1;i++) {
                      for(j=i+1;j<arr.length;j++ ) {            
                          for(k=j+1;k<arr.length;k++) {
                              let a4 = Object.values(arr[i])[0].concat(Object.values(arr[j])[0].concat(Object.values(arr[k])[0]));
                              a4 = a4.filter((item,index)=>{
                                 return (a4.indexOf(item) == index)
                              });
                              if(a4.length == 3) {
                                  //console.log(nhType + " Triplets By  "+titles[0]+" >> "+titles[0]+" Number => " + key + " | Numbers => "+ Object.keys(arr[i])[0] + ' - ' + Object.keys(arr[j])[0] + ' - ' + Object.keys(arr[k])[0] + " | "+titles[1]+" => " + Object.values(a4));
                                  let data = new Map();
                                  if(nhType == 'H' && rcbType == 'R') {
                                      data.set('CE',[
                                                  [
                                                      key,
                                                      parseInt(Object.values(a4)[0])                                                    
                                                  ],
                                                  [
                                                      key,
                                                      parseInt(Object.values(a4)[1])                                                    
                                                  ],
                                                  [
                                                      key,
                                                      parseInt(Object.values(a4)[2])                                                    
                                                  ]
                                                ]);
                                  data.set('NM',[
                                                  parseInt(Object.keys(arr[i])[0]),
                                                  parseInt(Object.keys(arr[j])[0]),
                                                  parseInt(Object.keys(arr[k])[0])
                                              ]);
                                  } else if(nhType == 'H' && rcbType == 'C') {
                                      data.set('CE',[
                                                  [
                                                      parseInt(Object.values(a4)[0]),
                                                      key
                                                  ],
                                                  [
                                                      parseInt(Object.values(a4)[1]),
                                                      key
                                                  ],
                                                  [
                                                      parseInt(Object.values(a4)[2]),
                                                      key
                                                  ]
                                                ]);
                                  data.set('NM',[
                                                  parseInt(Object.keys(arr[i])[0]),
                                                  parseInt(Object.keys(arr[j])[0]),
                                                  parseInt(Object.keys(arr[k])[0])
                                              ]);
                                     
                                  } else if(nhType == 'H' && rcbType == 'B') {
                                     // console.log('removalFromPossibilityMatrix value is not set = ' + nhType + '--' + rcbType )
                                      data.set('CE',[
                                                  [
                                                      parseInt(String(Object.values(a4)[0]).slice(0, 1)),
                                                      parseInt(String(Object.values(a4)[0]).slice(1, 2))                                                    
                                                  ],
                                                  [
                                                      parseInt(String(Object.values(a4)[1]).slice(0, 1)),
                                                      parseInt(String(Object.values(a4)[1]).slice(1, 2))                                                  
                                                  ],
                                                  [
                                                      parseInt(String(Object.values(a4)[2]).slice(0, 1)),
                                                      parseInt(String(Object.values(a4)[2]).slice(1, 2))
                                                  ]
                                                ]);
                                  data.set('NM',[
                                                  parseInt(Object.keys(arr[i])[0]),
                                                  parseInt(Object.keys(arr[j])[0]),
                                                  parseInt(Object.keys(arr[k])[0])
                                              ]);
                                     
                                  } else if(nhType == 'N' && rcbType == 'R') {
                                      /*
                                        RW
                                        IGCL
                                        NM
                                      */
                                      //console.log('removalFromPossibilityMatrix value is not set = ' + nhType + '--' + rcbType )
                                      data.set('RW',key);
                                      data.set('IGCL',[
                                                  [
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))                                                    
                                                  ],
                                                  [
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))                                                  
                                                  ],
                                                  [
                                                      parseInt(String(Object.keys(arr[k])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[k])[0]).slice(1, 2))
                                                  ]
                                                ]);
                                      data.set('NM',[
                                                  parseInt(Object.values(a4)[0]),
                                                  parseInt(Object.values(a4)[1]),
                                                  parseInt(Object.values(a4)[2])
                                              ]);
                                     
                                  } else if(nhType == 'N' && rcbType == 'C'){
                                    /*
                                        CL
                                        IGCL
                                        NM
                                      */
                                      data.set('CL',key);
                                      data.set('IGCL',[
                                                  [
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))                                                    
                                                  ],
                                                  [
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))                                                  
                                                  ],
                                                  [
                                                      parseInt(String(Object.keys(arr[k])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[k])[0]).slice(1, 2))
                                                  ]
                                                ]);
                                  data.set('NM',[
                                                  parseInt(Object.values(a4)[0]),
                                                  parseInt(Object.values(a4)[1]),
                                                  parseInt(Object.values(a4)[2])
                                              ]);
                                     
                                  } else if(nhType == 'N' && rcbType == 'B'){
                                    /*
                                        BK
                                        IGCL
                                        NM
                                      */
                                      //console.log('removalFromPossibilityMatrix value is not set')
                                      data.set('BK',key);
                                      data.set('IGCL',[
                                                  [
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))                                                    
                                                  ],
                                                  [
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))                                                  
                                                  ],
                                                  [
                                                      parseInt(String(Object.keys(arr[k])[0]).slice(0, 1)),
                                                      parseInt(String(Object.keys(arr[k])[0]).slice(1, 2))
                                                  ]
                                                ]);
                                  data.set('NM',[
                                                  parseInt(Object.values(a4)[0]),
                                                  parseInt(Object.values(a4)[1]),
                                                  parseInt(Object.values(a4)[2])
                                              ]);
                                  }
                                  if(data.size > 0){
                                      if(nhType == 'H')
                                          removalFromPossibilityMatrix(possibleNumberList,'HT',data);
                                      else
                                          removalFromPossibilityMatrix(possibleNumberList,'NT',data);
                                  }
                                 
                              }
                          }
                      }
                  }
              }
          }
          return kh;
      }  
     
      function RemoveLoneSingles(possibleNumberList) {
          let kv = [];
          for(let i=0;i< possibleNumberList.length;i++) {
             for(let j=0;j< possibleNumberList[i].length;j++) {
                 if(possibleNumberList[i][j].length == 1) {
                     if(!kv.includes(possibleNumberList[i][j][0]))
                          kv.push(possibleNumberList[i][j][0]);
                      board[i][j] = String(possibleNumberList[i][j][0]);
                      let bi = getBucketIndex(i,j);
                      ToAddIgnoreList("B", possibleNumberList[i][j][0] , bi);
                      ToAddIgnoreList(
                          "RN",
                          possibleNumberList[i][j][0],
                          bi,
                          i,
                          j
                        );
                      let data = new Map();
                      data.set('B',bi);
                      data.set('RW',i);
                      data.set('CL',j);
                      data.set('NM',[possibleNumberList[i][j][0]]);
                      removalFromPossibilityMatrix(possibleNumberList,'HS',data);
                 }
             }    
         }
         return kv;
      }  
     
      /*
      typeOfWings
        X - XWing
        S - SwordFish
      */
      function findWings(possibleNumberList, typeOfWings){
     
        let possibleNumberPosition = new Map();
        for(let i = 0; i < possibleNumberList.length;i++) {
            for(let j = 0; j < possibleNumberList[i].length;j++) {          
                for(let k = 0; k < possibleNumberList[i][j].length;k++) {    
                   
                    if(possibleNumberPosition.has(possibleNumberList[i][j][k])) {
                        if(possibleNumberPosition.get(possibleNumberList[i][j][k]).has(i)) {
                            possibleNumberPosition.get(possibleNumberList[i][j][k]).get(i).push(j);
                        } else {
                            possibleNumberPosition.get(possibleNumberList[i][j][k]).set(i, [j])
                        }
                    } else {
                        possibleNumberPosition.set(possibleNumberList[i][j][k], new Map([[i, [j]]]));
                    }
                   
                }
            }
        }
        //console.log(possibleNumberPosition)
       
        let clonedMap = new Map(possibleNumberPosition)
         
       
        for (let [key, value] of clonedMap) {
           
          let obj = value;
          if(typeOfWings == 'S') {
            if(obj.size < 3) {
              clonedMap.delete(key)
            } else {
                for (let [k, v] of obj) {
                    if(v.length != 2 && v.length != 3) {
                        clonedMap.get(key).delete(k);
                    }
                }  
            }
          } else {
            for (let [k, v] of obj) {
              if(v.length != 2) {
                  clonedMap.get(key).delete(k);
              }
            }
          }
        }  
        //console.log(clonedMap);
        //return;
        for (let [key, value] of clonedMap) {
          let obj = value;
          let arr = Array.from(obj, ([k, v]) => {
                return {[k]: v};
        });
         
          let difference;
         
          for(i = 0; i<arr.length-1;i++) {
              for(j=i+1;j<arr.length;j++ ) {            
                     
                if(typeOfWings == 'S')
                {
                  //SwordFish
                  for(k=j+1;k<arr.length;k++) {
                    let a4 = Object.values(arr[i])[0].concat(Object.values(arr[j])[0].concat(Object.values(arr[k])[0]));
                    a4 = a4.filter((item,index)=>{
                      return (a4.indexOf(item) == index)
                    });
                    if(a4.length == 3) {
                        //console.log("SwordFish >> Number => " + key + " Row Numbers => "
                                   // + Object.keys(arr[i])[0] + ' - ' + Object.keys(arr[j])[0] + ' - '
                                   // + Object.keys(arr[k])[0] + " Columns => " + Object.values(a4));
                                    let data = new Map();
                                    data.set('CL',Object.values(a4));
                                    data.set('IGCL',[
                                                [
                                                    Object.keys(arr[i])[0],
                                                    Object.values(a4)[0]                                                    
                                                ],
                                                [
                                                  Object.keys(arr[i])[0],
                                                  Object.values(a4)[1]                                                  
                                                ],
                                                [
                                                  Object.keys(arr[i])[0],
                                                  Object.values(a4)[2]
                                                ],
                                                [
                                                  Object.keys(arr[j])[0],
                                                  Object.values(a4)[0]                                                    
                                                ],
                                                [
                                                  Object.keys(arr[j])[0],
                                                  Object.values(a4)[1]                                                  
                                                ],
                                                [
                                                  Object.keys(arr[j])[0],
                                                  Object.values(a4)[2]
                                                ],
                                                [
                                                  Object.keys(arr[k])[0],
                                                  Object.values(a4)[0]                                                    
                                                ],
                                                [
                                                  Object.keys(arr[k])[0],
                                                  Object.values(a4)[1]                                                  
                                                ],
                                                [
                                                  Object.keys(arr[k])[0],
                                                  Object.values(a4)[2]
                                                ]
                                              ]);
                                data.set('NM',[
                                                key
                                            ]);    
                                removalFromPossibilityMatrix(possibleNumberList,'SF',data);                    
                    }
                  }
                } else {
                  let a4 = Object.values(arr[i])[0].concat(Object.values(arr[j])[0]);
                  a4 = a4.filter((item,index)=>{
                    return (a4.indexOf(item) == index)
                  });
                  if(a4.length == 2) {
                      //console.log(" X-Wing > Number => " + key + " Row Numbers => "
                          //+ Object.keys(arr[i])[0] + ' - ' + Object.keys(arr[j])[0] + " Columns => " + Object.values(a4));
                  }
                }
              }
          }
        }  
      }
      numberToBeChecked.forEach(logMapElements);
      AddOneMissingNumber();

      //RemoveLoneSingles(pbucket);
      if(!blnMatch) {
        kvArray = [];
      }  
      numberToBeChecked.clear();
   
      if (kvArray.length > 0) {
        numberToBeChecked = new Map(kvArray);
        checkNumber();
      } else {
          let kv = [];
          if(pbucket.length == 0)
              pbucket = getPossibleNumberList();
         
          if(pbucket.length > 0) {
                //if(!backTracking) {
                    findHiddenSDT(pbucket,2,'H','R');
                    findHiddenSDT(pbucket,3,'H','R');
                    findHiddenSDT(pbucket,2,'H','C');
                    findHiddenSDT(pbucket,3,'H','C');
                    findHiddenSDT(pbucket,2,'H','B');
                    findHiddenSDT(pbucket,3,'H','B');
                    findHiddenSDT(pbucket,2,'N','R');
                    findHiddenSDT(pbucket,3,'N','R');
                    findHiddenSDT(pbucket,2,'N','C');
                    findHiddenSDT(pbucket,3,'N','C');
                    findHiddenSDT(pbucket,2,'N','B');
                    findHiddenSDT(pbucket,3,'N','B');
                    findWings(pbucket,'S');
                    findWings(pbucket,'X');
               // }
               
                let v1,v2,v3,v4;
                v1 = findHiddenSDT(pbucket,1,'H','C');
                v2 = findHiddenSDT(pbucket,1,'H','R');
                v3 = findHiddenSDT(pbucket,1,'H','B');
                v4 = RemoveLoneSingles(pbucket);
                let av = v1.concat(v2).concat(v3).concat(v4);
                av = av.filter((item,index)=>{
                               return (av.indexOf(item) == index)
                            });
                let p = [];
                for(let i=0;i < pbucket.length;i++) {
                  for(let j=0;j < pbucket[i].length;j++) {
                    for(let k=0;k < pbucket[i][j].length;k++)
                      if(!p.includes(pbucket[i][j][k]))
                        p.push(pbucket[i][j][k]);
                  }
                }
                for(let i=0;i < av.length;i++) {
                    if(p.includes(av[i])) 
                      kv.push([av[i], av[i]]);
                }
             
                if(kv.length > 0 ) {
                    numberToBeChecked = new Map(kv);
                    checkNumber();
                } else {
                   //console.log(pbucket);
                   //console.log("Nothing")
                }
          }
      }
     

    }
    function ToAddIgnoreList(flag, Num, BucketNo, RowNumber, ColNumber) {
      //console.log(flag +'--'+ Num +'--'+ BucketNo +'--'+ RowNumber +'--'+ ColNumber)
       if (flag == "B") {
         if (ignoreBucketNumber.has(String(Num))) {
          if(ignoreBucketNumber.get(String(Num)).indexOf(parseInt(BucketNo)) == -1)
                ignoreBucketNumber.get(String(Num)).push(parseInt(BucketNo));
        } else {
          ignoreBucketNumber.set(String(Num),[parseInt(BucketNo)]);
        }
      } else if (flag == "RN") {
         
        if (ignoreList.has(String(Num))) {
          if (ignoreList.get(String(Num)).Row.indexOf(parseInt(RowNumber)) == -1)
            ignoreList.get(String(Num)).Row.push(parseInt(RowNumber));
          if (ignoreList.get(String(Num)).Col.indexOf(parseInt(ColNumber)) == -1)
            ignoreList.get(String(Num)).Col.push(parseInt(ColNumber));
        } else {
          ignoreList.set(String(Num), {
            Row: [parseInt(RowNumber)],
            Col: [parseInt(ColNumber)],
          });
        }
      }
    }
    function getBucketIndex(rowNum, colNum) {
            for (const [key, value] of bucketIndexes) {
              let obj = value;
              for (const i in obj) {
                if (obj.hasOwnProperty(i)) {
                  if (i == rowNum && obj[i].indexOf(colNum) != -1) {
                    return key;
                  }
                }
              }
            }
    }
     /*
      BK - Bucket
      RW - Row
      CL - Column
      CE - CELL
      NM - Numbers to be removed
      ONM - Numbers other than these to be removed
      IGCL - Cell to be ignored
      */
      function removalFromPossibilityMatrix(possibleNumberList, flag, data) {
            //console.log(data);
            if(flag == 'HD' || flag == 'HT') {
                let arrCE = data.get('CE');
                for(let i = 0; i < arrCE.length;i++ ) {
                    possibleNumberList[arrCE[i][0]][arrCE[i][1]]
                    = possibleNumberList[arrCE[i][0]][arrCE[i][1]].filter(value => data.get('NM').includes(value));
                }
            } else if(flag =='HS') {
                let rw = data.get('RW');
                let cl = data.get('CL');
                //Removing from possibility matrix
                possibleNumberList[rw][cl] = [];
                //Delete from bucket
                let bucketIndex = data.get('B');
                let objBucketIndexes = bucketIndexes.get(bucketIndex);
                for (const kk in objBucketIndexes) {
                  if (objBucketIndexes.hasOwnProperty(kk)) {
                    for (let col = 0; col < 3; col++) {
                      possibleNumberList[kk][objBucketIndexes[kk][col]]
                      = possibleNumberList[kk][objBucketIndexes[kk][col]].filter(value => !data.get('NM').includes(value));
                    }
                  }
                }
                //Delete from Row
                for(let i =0;i < possibleNumberList[rw].length;i++) {
                   possibleNumberList[rw][i] = possibleNumberList[rw][i].filter(value => !data.get('NM').includes(value));
                }
                //Delete from Column
                for(let i =0;i < possibleNumberList[cl].length;i++) {
                   possibleNumberList[i][cl] = possibleNumberList[i][cl].filter(value => !data.get('NM').includes(value));
                }
            } else if(flag == 'ND' || flag == 'NT') {
                if (data.has('B')) {
                    let bucketIndex = data.get('B');
                    let objBucketIndexes = bucketIndexes.get(bucketIndex);
                    for (const kk in objBucketIndexes) {
                      if (objBucketIndexes.hasOwnProperty(kk)) {
                        for (let col = 0; col < 3; col++) {
                          if(data.get('IGCL').filter((key1) => {return key1[0] == kk && key1[1] == objBucketIndexes[kk][col]}).length == 0) {
                            //console.log(flag +' > B')
                            possibleNumberList[kk][objBucketIndexes[kk][col]] = possibleNumberList[kk][objBucketIndexes[kk][col]].filter(value => !data.get('NM').includes(value));    
                          }  
   
                        }
                      }
                    }
                }
                if(data.has('RW')) {
                    let rw = data.get('RW');
                    for(let i =0;i < possibleNumberList[rw].length;i++) {
                        if(data.get('IGCL').filter((key1) => {return key1[0] == rw && key1[1] == i}).length == 0) {
                          //console.log(flag +' > RW')  
                          possibleNumberList[rw][i] = possibleNumberList[rw][i].filter(value => !data.get('NM').includes(value));
                        }
                    }
                }
                if(data.has('CL')) {
                    let cl = data.get('CL');
                    for(let i =0;i < possibleNumberList[cl].length;i++) {
                        if(data.get('IGCL').filter((key1) => {return key1[0] == i && key1[1] == cl}).length == 0) {
                          //console.log(flag +' > CL')  
                          possibleNumberList[i][cl] = possibleNumberList[i][cl].filter(value => !data.get('NM').includes(value));
                        }
                    }
                }
            } else if(flag == "SF") {
   
              if(data.has('CL')) {
   
                let cl = data.get('CL');
                for(let j=0;j < cl.length;j++) {
                  for(let i =0;i < possibleNumberList[cl[j]].length;i++) {
                    if(data.get('IGCL').filter((key1) => {return key1[0] == i && key1[1] == cl[j]}).length == 0) {
                      //console.log(flag +' > CL')  
                      possibleNumberList[i][cl[j]] = possibleNumberList[i][cl[j]].filter(value => !data.get('NM').includes(value));
                    }
                  }
                }
               
              }
            }
      }
};

// @lc code=end


// @after-stub-for-debug-begin
module.exports = solveSudoku;
// @after-stub-for-debug-end

On Sat, Aug 6, 2022 at 4:42 PM Nitin Makwana <nitin.makwana@spinxdigital.com> wrote:


---------- Forwarded message ---------
From: Nitin Makwana <nitin.makwana@spinxdigital.com>
Date: Sat, Aug 6, 2022 at 4:42 PM
Subject: Final one > 21/07/22 (Sudoku)
To: Nitin Makwana <nitin.makwana@spinxdigital.com>


/*
 * @lc app=leetcode id=37 lang=javascript
 *
 * [37] Sudoku Solver
 */

// @lc code=start
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solveSudoku = function(board) {

     //function removeFromPossibilityMatrix(flag) {
   
//}  
  //return;
  const bucketIndexes = new Map();
  bucketIndexes.set(1, { 0: [0, 1, 2], 1: [0, 1, 2], 2: [0, 1, 2] });
  bucketIndexes.set(2, { 0: [3, 4, 5], 1: [3, 4, 5], 2: [3, 4, 5] });
  bucketIndexes.set(3, { 0: [6, 7, 8], 1: [6, 7, 8], 2: [6, 7, 8] });
  bucketIndexes.set(4, { 3: [0, 1, 2], 4: [0, 1, 2], 5: [0, 1, 2] });
  bucketIndexes.set(5, { 3: [3, 4, 5], 4: [3, 4, 5], 5: [3, 4, 5] });
  bucketIndexes.set(6, { 3: [6, 7, 8], 4: [6, 7, 8], 5: [6, 7, 8] });
  bucketIndexes.set(7, { 6: [0, 1, 2], 7: [0, 1, 2], 8: [0, 1, 2] });
  bucketIndexes.set(8, { 6: [3, 4, 5], 7: [3, 4, 5], 8: [3, 4, 5] });
  bucketIndexes.set(9, { 6: [6, 7, 8], 7: [6, 7, 8], 8: [6, 7, 8] });
 
 
     
  let bucketNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
  let NumbersProcessed = [];
  const ignoreList = new Map();
  let ignoreBucketNumber = {};
  let numberToBeChecked = new Map();
  const toNumbers = arr => arr.map(Number);
  let pbucket = [];
  for (const [key, value] of bucketIndexes) {
    let obj = value;
    for (const i in obj) {
      if (obj.hasOwnProperty(i)) {
        for (j = 0; j < 3; j++) {
          if (board[i][obj[i][j]] != ".") {
            ToAddIgnoreList("B", board[i][obj[i][j]], key);
          }

          if (
            board[i][obj[i][j]] != "." &&
            NumbersProcessed.indexOf(board[i][obj[i][j]]) == -1
          ) {
            NumbersProcessed.push(board[i][obj[i][j]]);
            numberToBeChecked.set(board[i][obj[i][j]], board[i][obj[i][j]]);
            ToAddIgnoreList("RN", board[i][obj[i][j]], key, i, obj[i][j]);

            for (let k = 1; k <= 9; k++) {
              if (k == key) continue;
              else {
                let objBucketIndexes = bucketIndexes.get(k);
                for (const kk in objBucketIndexes) {
                  if (objBucketIndexes.hasOwnProperty(kk)) {
                    for (let col = 0; col < 3; col++) {
                      if (
                        board[i][obj[i][j]] ==
                        board[kk][objBucketIndexes[kk][col]]
                      ) {
                        ToAddIgnoreList(
                          "RN",
                          board[i][obj[i][j]],
                          key,
                          kk,
                          objBucketIndexes[kk][col]
                        );
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  //console.log(ignoreList)
  //console.log(ignoreBucketNumber)
  checkNumber();
  console.log(pbucket);
  function checkNumber() {
    let kvArray = [];

    function logMapElements(value, key, map) {
      let selBucketNumber;

      ib = value;
      selBucketNumber = ib;

      for (let k = 1; k <= 9; k++) {
        let noOfBlankBoxesInBucket = 0;
        let selRowNumber = 0;
        let selColumnNumber = 0;
        //console.log('ignoreBucketNumber');
        // console.log(ignoreBucketNumber);
        if (ignoreBucketNumber[ib].indexOf(k) == -1) {
          let objBucketIndexes = bucketIndexes.get(k);

          for (let kk in objBucketIndexes) {
            if (
              objBucketIndexes.hasOwnProperty(kk) &&
              ignoreList.get(ib).Row.indexOf(parseInt(kk)) == -1
            ) {
              for (let coli in objBucketIndexes[kk]) {
                if (
                  ignoreList
                    .get(ib)
                    .Col.indexOf(parseInt(objBucketIndexes[kk][coli])) == -1
                ) {
                  if (board[kk][objBucketIndexes[kk][coli]] == ".") {
                    noOfBlankBoxesInBucket++;
                    selRowNumber = kk;
                    selColumnNumber = objBucketIndexes[kk][coli];
                  }
                }
              }
            }
          }

          if (noOfBlankBoxesInBucket == 1) {
            board[selRowNumber][selColumnNumber] = ib;
            kvArray.push([ib, ib]);
            ToAddIgnoreList("B", ib, k);
            ToAddIgnoreList("RN", ib, k, selRowNumber, selColumnNumber);
          }
        }
      }
    }
    function getBucketIndex(rowNum, colNum) {
      for (const [key, value] of bucketIndexes) {
        let obj = value;
        for (const i in obj) {
          if (obj.hasOwnProperty(i)) {
            if (i == rowNum && obj[i].indexOf(colNum) != -1) {
              return key;
            }
          }
        }
      }
    }
    function AddOneMissingNumber() {
      for (let k = 1; k <= 9; k++) {
        let objBucketIndexes = bucketIndexes.get(k);
        let myMap = new Map([
          [1, 1],
          [2, 2],
          [3, 3],
          [4, 4],
          [5, 5],
          [6, 6],
          [7, 7],
          [8, 8],
          [9, 9],
        ]);
        let oneRemainingRowNumber = 0;
        let oneRemainingColNumber = 0;
        for (let kk in objBucketIndexes) {
          for (let coli in objBucketIndexes[kk]) {
            if (board[kk][objBucketIndexes[kk][coli]] != ".") {
              myMap.delete(parseInt(board[kk][objBucketIndexes[kk][coli]]));
            } else {
              oneRemainingRowNumber = kk;
              oneRemainingColNumber = objBucketIndexes[kk][coli];
            }
          }
        }
        if (myMap.size == 1) {
          let ib = `${Array.from(myMap).pop()[1]}`;
          board[oneRemainingRowNumber][oneRemainingColNumber] = ib;
          kvArray.push([ib, ib]);
          ToAddIgnoreList("B", ib, k);
          ToAddIgnoreList(
            "RN",
            ib,
            k,
            oneRemainingRowNumber,
            oneRemainingColNumber
          );
        }
      }
      for (let i = 0; i < 9; i++) {
        let myMap = new Map([
          [1, 1],
          [2, 2],
          [3, 3],
          [4, 4],
          [5, 5],
          [6, 6],
          [7, 7],
          [8, 8],
          [9, 9],
        ]);
        let oneRemainingRowNumber = 0;
        let oneRemainingColNumber = 0;

        for (let j = 0; j < 9; j++) {
          if (board[i][j] != ".") {
            myMap.delete(parseInt(board[i][j]));
          } else {
            oneRemainingRowNumber = i;
            oneRemainingColNumber = j;
          }
        }
        if (myMap.size == 1) {
          let ib = `${Array.from(myMap).pop()[1]}`;
          board[oneRemainingRowNumber][oneRemainingColNumber] = ib;
          let k = getBucketIndex(oneRemainingRowNumber, oneRemainingColNumber);
          kvArray.push([ib, ib]);
          ToAddIgnoreList("B", ib, k);
          ToAddIgnoreList(
            "RN",
            ib,
            k,
            oneRemainingRowNumber,
            oneRemainingColNumber
          );
        }
      }

      for (let i = 0; i < 9; i++) {
        let myMap = new Map([
          [1, 1],
          [2, 2],
          [3, 3],
          [4, 4],
          [5, 5],
          [6, 6],
          [7, 7],
          [8, 8],
          [9, 9],
        ]);
        let oneRemainingRowNumber = 0;
        let oneRemainingColNumber = 0;

        for (let j = 0; j < 9; j++) {
          if (board[j][i] != ".") {
            myMap.delete(parseInt(board[j][i]));
          } else {
            oneRemainingRowNumber = j;
            oneRemainingColNumber = i;
          }
        }
        if (myMap.size == 1) {
          let ib = `${Array.from(myMap).pop()[1]}`;
          let k = getBucketIndex(oneRemainingRowNumber, oneRemainingColNumber);

          board[oneRemainingRowNumber][oneRemainingColNumber] = ib;
          kvArray.push([ib, ib]);
          ToAddIgnoreList("B", ib, k);
          ToAddIgnoreList(
            "RN",
            ib,
            k,
            oneRemainingRowNumber,
            oneRemainingColNumber
          );
        }
      }
    }
     
    function getPossibleNumberList() {
       
        //const toNumbers = arr => arr.map(Number);
       
        let numbersInBucketRCB = new Map([['R',new Map()],['C',new Map()],['B',new Map()]]);
   
        for (let k = 1; k <= 9; k++) {
            let objBucketIndexes = bucketIndexes.get(k);
for (let kk in objBucketIndexes) {
              if (objBucketIndexes.hasOwnProperty(kk)) {
                for (let coli in objBucketIndexes[kk]) {                  
                    if (board[kk][objBucketIndexes[kk][coli]] != ".") {                      
                      let selRowNumber = kk;
                      let selColumnNumber = objBucketIndexes[kk][coli];
                      if(numbersInBucketRCB.get('R').size > 0) {
                          if(!numbersInBucketRCB.get('R').has(kk)) {
                            numbersInBucketRCB.get('R').set(parseInt(kk),toNumbers(board[selRowNumber].filter((x) => {return x != '.'})))      
                          }
                      } else {
                        numbersInBucketRCB.set('R',new Map([[parseInt(kk),toNumbers(board[selRowNumber].filter((x) => {return x != '.'}))   ]]));  
                      }

                      if(numbersInBucketRCB.get('C').size > 0) {
                          if(!numbersInBucketRCB.get('C').has(selColumnNumber)) {
                            numbersInBucketRCB.get('C').set(selColumnNumber,[  parseInt(board[kk][objBucketIndexes[kk][coli]])  ])      
                          }
                          else {
                              numbersInBucketRCB.get('C').get(selColumnNumber).push( parseInt( board[kk][objBucketIndexes[kk][coli]] ) );
                          }
                      } else {
                        numbersInBucketRCB.set('C',new Map([[selColumnNumber,[ parseInt(board[kk][objBucketIndexes[kk][coli]])  ]]]));  
                      }  


                      if(numbersInBucketRCB.get('B').size > 0) {
                          if(!numbersInBucketRCB.get('B').has(k)) {
                            numbersInBucketRCB.get('B').set(k,[ parseInt(board[kk][objBucketIndexes[kk][coli]])  ])      
                          }
                          else {
                              numbersInBucketRCB.get('B').get(k).push( parseInt( board[kk][objBucketIndexes[kk][coli]]) );
                          }
                      } else {
                        numbersInBucketRCB.set('B',new Map([[k,[ parseInt(board[kk][objBucketIndexes[kk][coli]])  ]]]));  
                      }
                    }
                }
              }
            }
}
       
        let pboard = [];
        for(let i=0;i<9;i++) {
            pboard[i] = [];  
            for(let j =0;j<9;j++) {
                if (board[i][j] == ".") {
                    let b = getBucketIndex(i,j);
                    let rcb = numbersInBucketRCB.get('R').get(i).concat(numbersInBucketRCB.get('C').get(j).concat(numbersInBucketRCB.get('B').get(b)));
                    pboard[i][j] =  [1,2,3,4,5,6,7,8,9].filter(value => !rcb.includes(value));

                } else {
                    pboard[i][j] = [];    
                }
            }
        }
        return pboard;
    }
      /*
      nhType
        H - Hidden
        N - Naked
      rcbType
        R - Row
        C - Column
        B - Bucket
      */
    function findHiddenSDT(possibleNumberList,flag, nhType, rcbType) {

        let possibleNumberPosition = new Map();

if(
            (nhType == 'H' && rcbType == 'R')
            || (nhType == 'H' && rcbType == 'C')            
          ) {
for(let i = 0; i < possibleNumberList.length;i++) {
 for(let j = 0; j < possibleNumberList[i].length;j++) {          
 for(let k = 0; k < possibleNumberList[i][j].length;k++) {  
 let pKey, pSKey, pVal;
 if(nhType == 'H' && rcbType == 'R') {
pKey = i;
pSKey = possibleNumberList[i][j][k];
pVal = j;
 } else if(nhType == 'H' && rcbType == 'C'){
pKey = j;
pSKey = possibleNumberList[i][j][k];
pVal = i
 }
 
 if(possibleNumberPosition.has(pKey)) {
 if(possibleNumberPosition.get(pKey).has(pSKey)) {
 possibleNumberPosition.get(pKey).get(pSKey).push(pVal);
 } else {
 possibleNumberPosition.get(pKey).set(pSKey, [pVal])
 }
 } else {
 possibleNumberPosition.set(pKey, new Map([[pSKey, [pVal]]]));
 }
 }
 }
}
} else {
       for (let [key, value] of bucketIndexes) {
           
let obj = value;
for (let i in obj) {
if (obj.hasOwnProperty(i)) {
 for (let j = 0; j < 3; j++) {
 for(let k = 0; k < possibleNumberList[i][obj[i][j]].length;k++) {  
 let pKey, pSKey, pVal;
 if(nhType == 'H' && rcbType == 'B'){
pKey = key;
pSKey = possibleNumberList[i][obj[i][j]][k];
pVal = `${i}`+`${obj[i][j]}`;                                  
 } else if(nhType == 'N' && rcbType == 'R'){
pKey = i;
pSKey = `${i}`+`${obj[i][j]}`;
pVal = possibleNumberList[i][obj[i][j]][k];
 } else if(nhType == 'N' && rcbType == 'C'){
pKey = obj[i][j];
pSKey = `${i}`+`${obj[i][j]}`;
pVal = possibleNumberList[i][obj[i][j]][k];
 } else if(nhType == 'N' && rcbType == 'B'){
pKey = key;
pSKey = `${i}`+`${obj[i][j]}`;
pVal = possibleNumberList[i][obj[i][j]][k];
 }
 
 if(possibleNumberPosition.has(pKey)) {
 if(possibleNumberPosition.get(pKey).has(pSKey)) {
 possibleNumberPosition.get(pKey).get(pSKey).push(pVal);
 } else {
 possibleNumberPosition.get(pKey).set(pSKey, [pVal])
 }
 } else {
 possibleNumberPosition.set(pKey, new Map([[pSKey, [pVal]]]));
 }
 }
}
}
}
 }
}
      let clonedMap = new Map(possibleNumberPosition)
        for (let [key, value] of clonedMap) {
            let obj = value;
            for (let [k, v] of obj) {
               
                if(flag == 1) {
                    if(v.length != 1) {  //For Single
                        clonedMap.get(key).delete(k);
                    }
                } else if(flag == 2) {
                    if(v.length != 2) {  //For Doubles
                        clonedMap.get(key).delete(k);
                    }                    
                } else if(flag == 3) {
                    if(v.length != 2 && v.length != 3) { //For Triplets
                        clonedMap.get(key).delete(k);
                    }
                }
            }
        }  
let titles;
       
   if(nhType == 'H' && rcbType == 'R') {
titles = ["Row","Columns"];
   } else if(nhType == 'H' && rcbType == 'C'){
titles = ["Column","Rows"]
   } else if(nhType == 'H' && rcbType == 'B'){
titles = ["Bucket","RowColumn"]
   } else if(nhType == 'N' && rcbType == 'R'){
titles = ["Row","RowColumn"];
   } else if(nhType == 'N' && rcbType == 'C'){
titles = ["Column","RowColumn"]
   } else if(nhType == 'N' && rcbType == 'B'){
titles = ["Bucket","RowColumn"]
   }

        let difference;
        let kh = [];
        for (let [key, value] of clonedMap) {
            let obj = value;
            if(flag == 1) {
                if(obj.size > 0) {
                    let arr = Array.from(obj, ([k, v]) => {
                              return {[k]: v};
                    });
                    console.log(nhType + " Singles By "+titles[0]+" >> "+titles[0]+" Number => " + key + " | Numbers => "+ Object.keys(arr[0])[0]  + "  | "+titles[1]+" => " + Object.values(arr[0])[0]);
                   
                    let data = new Map();
                    if(nhType == 'H' && rcbType == 'C') {
                       
                        board[parseInt(Object.values(arr[0])[0][0])][key] = Object.keys(arr[0])[0];
                        let bi = getBucketIndex(Object.values(arr[0])[0][0],key);
                        data.set('B',bi);
                        data.set('RW',Object.values(arr[0])[0][0]);
                        data.set('CL',key);
                        data.set('NM',[parseInt(Object.keys(arr[0])[0])]);
                       
                        ToAddIgnoreList("B", parseInt(Object.keys(arr[0])[0]) , bi);
                        ToAddIgnoreList(
                            "RN",
                            parseInt(Object.keys(arr[0])[0]),
                            bi,
                            Object.values(arr[0])[0][0],
                            key
                          );
                    } else if(nhType == 'H' && rcbType == 'R') {
                        board[key][Object.values(arr[0])[0][0]] = Object.keys(arr[0])[0];
                        let bi = getBucketIndex(key,Object.values(arr[0])[0][0]);
                        data.set('B',bi);
                        data.set('RW',key);
                        data.set('CL',Object.values(arr[0])[0][0]);
                        data.set('NM',[parseInt(Object.keys(arr[0])[0])]);
                       
                        ToAddIgnoreList("B", parseInt(Object.keys(arr[0])[0]) , bi);
                        ToAddIgnoreList(
                            "RN",
                            parseInt(Object.keys(arr[0])[0]),
                            bi,
                            key,
                            Object.values(arr[0])[0][0]
                          );
                    } else if(nhType == 'H' && rcbType == 'B') {
                        board[parseInt(String(Object.values(arr[0])[0]).slice(0, 1))][parseInt(String(Object.values(arr[0])[0]).slice(1, 2))] = Object.keys(arr[0])[0];
                        data.set('B',key);
                        data.set('RW',parseInt(String(Object.values(arr[0])[0]).slice(0, 1)));
                        data.set('CL',parseInt(String(Object.values(arr[0])[0]).slice(1, 2)));
                        data.set('NM',[parseInt(Object.keys(arr[0])[0])]);
                       
                        ToAddIgnoreList("B", parseInt(Object.keys(arr[0])[0]) , key);
                        ToAddIgnoreList(
                            "RN",
                            parseInt(Object.keys(arr[0])[0]),
                            key,
                            parseInt(String(Object.values(arr[0])[0]).slice(0, 1)),
                            parseInt(String(Object.values(arr[0])[0]).slice(1, 2))
                          );
                    }
                    removalFromPossibilityMatrix(possibleNumberList,'HS',data);
                    if(!kh.includes(parseInt(Object.keys(arr[0])[0])))
                        kh.push(parseInt(Object.keys(arr[0])[0]));
                }
               
            } else if(flag == 2) {
                let arr = Array.from(obj, ([k, v]) => {
                              return {[k]: v};
                    });
                for(i = 0; i<arr.length-1;i++) {
                    for(j=i+1;j<arr.length;j++ ) {            
                        let a4 = Object.values(arr[i])[0].concat(Object.values(arr[j])[0]);
                        a4 = a4.filter((item,index)=>{
                           return (a4.indexOf(item) == index)
                        });
                        if(a4.length == 2) {
                            console.log(nhType + " Doubles By  "+titles[0]+" >> "+titles[0]+" Number => " + key + " | Numbers => "+ Object.keys(arr[i])[0] + ' - ' + Object.keys(arr[j])[0]  + " | "+titles[1]+" => " + Object.values(a4));
                            let data = new Map();
                            if(nhType == 'H' && rcbType == 'C') {
                                data.set('CE',[[Object.values(a4)[0],key],[Object.values(a4)[1],key]]);
                                data.set('NM',[parseInt(Object.keys(arr[i])[0]),parseInt(Object.keys(arr[j])[0])]);
                            } else if(nhType == 'H' && rcbType == 'R') {
                                data.set('CE',[
                                                [key,Object.values(a4)[0]],
                                                [key,Object.values(a4)[1]]
                                                ]);
                                data.set('NM',[parseInt(Object.keys(arr[i])[0]),parseInt(Object.keys(arr[j])[0])]);
                            } else if(nhType == 'H' && rcbType == 'B') {
                                data.set('CE',[
                                                [
                                                    parseInt(String(Object.values(a4)[0]).slice(0, 1)),
                                                    parseInt(String(Object.values(a4)[0]).slice(1, 2))
                                                ],
                                                [
                                                    parseInt(String(Object.values(a4)[1]).slice(0, 1)),
                                                    parseInt(String(Object.values(a4)[1]).slice(1, 2))
                                                ]                                                
                                              ]);
                                data.set('NM',[parseInt(Object.keys(arr[i])[0]),parseInt(Object.keys(arr[j])[0])]);
                            } else if(nhType == 'N' && rcbType == 'C'){
                              data.set('CL',key);
                              data.set('IGCL',[
                                                [
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))
                                                ],
                                                [
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))
                                                ]                                                
                                              ]);
                                data.set('NM',[parseInt(Object.values(a4)[0]),parseInt(Object.values(a4)[1])]);        
                            } else if(nhType == 'N' && rcbType == 'R'){
                                data.set('RW',key);
                                data.set('IGCL',[
                                                [
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))
                                                ],
                                                [
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))
                                                ]                                                
                                              ]);
                                data.set('NM',[parseInt(Object.values(a4)[0]),parseInt(Object.values(a4)[1])]);
                               
                            } else if(nhType == 'N' && rcbType == 'B'){
                                data.set('BK',key);
                                data.set('IGCL',[
                                                [
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))
                                                ],
                                                [
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))
                                                ]                                                
                                              ]);
                                data.set('NM',[parseInt(Object.values(a4)[0]),parseInt(Object.values(a4)[1])]);      
                            }
                            if(nhType == 'H')
                                removalFromPossibilityMatrix(possibleNumberList,'HD',data);
                            else
                                removalFromPossibilityMatrix(possibleNumberList,'ND',data);
                               
                        }
                    }
                }
               
            } else if(flag == 3) {
               
                let arr = Array.from(obj, ([k, v]) => {
                              return {[k]: v};
                    });
                //console.log(arr);
                for(i = 0; i<arr.length-1;i++) {
                    for(j=i+1;j<arr.length;j++ ) {            
                        for(k=j+1;k<arr.length;k++) {
                            let a4 = Object.values(arr[i])[0].concat(Object.values(arr[j])[0].concat(Object.values(arr[k])[0]));
                            a4 = a4.filter((item,index)=>{
                               return (a4.indexOf(item) == index)
                            });
                            if(a4.length == 3) {
                                console.log(nhType + " Triplets By  "+titles[0]+" >> "+titles[0]+" Number => " + key + " | Numbers => "+ Object.keys(arr[i])[0] + ' - ' + Object.keys(arr[j])[0] + ' - ' + Object.keys(arr[k])[0] + " | "+titles[1]+" => " + Object.values(a4));
                                let data = new Map();
                                if(nhType == 'H' && rcbType == 'R') {
                                    //CE: [[1,2],[1,2]] / [[1,2],[1,2],[1,2]] NM: [2,3]/[2,3,4]
                                    data.set('CE',[
                                                [
                                                    key,
                                                    parseInt(Object.values(a4)[0])                                                    
                                                ],
                                                [
                                                    key,
                                                    parseInt(Object.values(a4)[1])                                                    
                                                ],
                                                [
                                                    key,
                                                    parseInt(Object.values(a4)[2])                                                    
                                                ]
                                              ]);
                                data.set('NM',[
                                                parseInt(Object.keys(arr[i])[0]),
                                                parseInt(Object.keys(arr[j])[0]),
                                                parseInt(Object.keys(arr[k])[0])
                                            ]);
                                } else if(nhType == 'H' && rcbType == 'C') {
                                    data.set('CE',[
                                                [
                                                    parseInt(Object.values(a4)[0]),
                                                    key
                                                ],
                                                [
                                                    parseInt(Object.values(a4)[1]),
                                                    key
                                                ],
                                                [
                                                    parseInt(Object.values(a4)[2]),
                                                    key
                                                ]
                                              ]);
                                data.set('NM',[
                                                parseInt(Object.keys(arr[i])[0]),
                                                parseInt(Object.keys(arr[j])[0]),
                                                parseInt(Object.keys(arr[k])[0])
                                            ]);
                                   
                                } else if(nhType == 'H' && rcbType == 'B') {
                                    console.log('removalFromPossibilityMatrix value is not set = ' + nhType + '--' + rcbType )
                                    data.set('CE',[
                                                [
                                                    parseInt(String(Object.values(a4)[0]).slice(0, 1)),
                                                    parseInt(String(Object.values(a4)[0]).slice(1, 2))                                                    
                                                ],
                                                [
                                                    parseInt(String(Object.values(a4)[1]).slice(0, 1)),
                                                    parseInt(String(Object.values(a4)[1]).slice(1, 2))                                                  
                                                ],
                                                [
                                                    parseInt(String(Object.values(a4)[2]).slice(0, 1)),
                                                    parseInt(String(Object.values(a4)[2]).slice(1, 2))
                                                ]
                                              ]);
                                data.set('NM',[
                                                parseInt(Object.keys(arr[i])[0]),
                                                parseInt(Object.keys(arr[j])[0]),
                                                parseInt(Object.keys(arr[k])[0])
                                            ]);
                                   
                                } else if(nhType == 'N' && rcbType == 'R') {
                                    /*
                                      RW
                                      IGCL
                                      NM
                                    */
                                    console.log('removalFromPossibilityMatrix value is not set = ' + nhType + '--' + rcbType )
                                    data.set('RW',key);
                                    data.set('IGCL',[
                                                [
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))                                                    
                                                ],
                                                [
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))                                                  
                                                ],
                                                [
                                                    parseInt(String(Object.keys(arr[k])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[k])[0]).slice(1, 2))
                                                ]
                                              ]);
                                    data.set('NM',[
                                                parseInt(Object.values(a4)[0]),
                                                parseInt(Object.values(a4)[1]),
                                                parseInt(Object.values(a4)[2])
                                            ]);
                                   
                                } else if(nhType == 'N' && rcbType == 'C'){
                                  /*
                                      CL
                                      IGCL
                                      NM
                                    */
                                    data.set('CL',key);
                                    data.set('IGCL',[
                                                [
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))                                                    
                                                ],
                                                [
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))                                                  
                                                ],
                                                [
                                                    parseInt(String(Object.keys(arr[k])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[k])[0]).slice(1, 2))
                                                ]
                                              ]);
                                data.set('NM',[
                                                parseInt(Object.values(a4)[0]),
                                                parseInt(Object.values(a4)[1]),
                                                parseInt(Object.values(a4)[2])
                                            ]);
                                   
                                } else if(nhType == 'N' && rcbType == 'B'){
                                  /*
                                      BK
                                      IGCL
                                      NM
                                    */
                                    //console.log('removalFromPossibilityMatrix value is not set')
                                    data.set('BK',key);
                                    data.set('IGCL',[
                                                [
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[i])[0]).slice(1, 2))                                                    
                                                ],
                                                [
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[j])[0]).slice(1, 2))                                                  
                                                ],
                                                [
                                                    parseInt(String(Object.keys(arr[k])[0]).slice(0, 1)),
                                                    parseInt(String(Object.keys(arr[k])[0]).slice(1, 2))
                                                ]
                                              ]);
                                data.set('NM',[
                                                parseInt(Object.values(a4)[0]),
                                                parseInt(Object.values(a4)[1]),
                                                parseInt(Object.values(a4)[2])
                                            ]);
                                }
                                if(data.size > 0){
                                    if(nhType == 'H')
                                        removalFromPossibilityMatrix(possibleNumberList,'HT',data);
                                    else
                                        removalFromPossibilityMatrix(possibleNumberList,'NT',data);
                                }
                               
                            }
                        }
                    }
                }
            }
        }
        return kh;
    }  
    /*
      BK - Bucket
RW - Row
CL - Column
CE - CELL
NM - Numbers to be removed
ONM - Numbers other than these to be removed
IGCL - Cell to be ignored
    */
    function removalFromPossibilityMatrix(possibleNumberList, flag, data) {
        //console.log(data);
        if(flag == 'HD' || flag == 'HT') {
            let arrCE = data.get('CE');
            for(let i = 0; i < arrCE.length;i++ ) {
                possibleNumberList[arrCE[i][0]][arrCE[i][1]]
                = possibleNumberList[arrCE[i][0]][arrCE[i][1]].filter(value => data.get('NM').includes(value));
            }
        } else if(flag =='HS') {
            let rw = data.get('RW');
            let cl = data.get('CL');
            //Removing from possibility matrix
            possibleNumberList[rw][cl] = [];
            //Delete from bucket
            let bucketIndex = data.get('B');
            let objBucketIndexes = bucketIndexes.get(bucketIndex);
            for (const kk in objBucketIndexes) {
              if (objBucketIndexes.hasOwnProperty(kk)) {
                for (let col = 0; col < 3; col++) {
                  possibleNumberList[kk][objBucketIndexes[kk][col]]
                  = possibleNumberList[kk][objBucketIndexes[kk][col]].filter(value => !data.get('NM').includes(value));
                }
              }
            }
            //Delete from Row
            for(let i =0;i < possibleNumberList[rw].length;i++) {
               possibleNumberList[rw][i] = possibleNumberList[rw][i].filter(value => !data.get('NM').includes(value));
            }
            //Delete from Column
            for(let i =0;i < possibleNumberList[cl].length;i++) {
               possibleNumberList[i][cl] = possibleNumberList[i][cl].filter(value => !data.get('NM').includes(value));
            }
        } else if(flag == 'ND' || flag == 'NT') {
            if (data.has('B')) {
                let bucketIndex = data.get('B');
                let objBucketIndexes = bucketIndexes.get(bucketIndex);
                for (const kk in objBucketIndexes) {
                  if (objBucketIndexes.hasOwnProperty(kk)) {
                    for (let col = 0; col < 3; col++) {
                      if(data.get('IGCL').filter((key1) => {return key1[0] == kk && key1[1] == objBucketIndexes[kk][col]}).length == 0) {
                        //console.log(flag +' > B')
                        possibleNumberList[kk][objBucketIndexes[kk][col]] = possibleNumberList[kk][objBucketIndexes[kk][col]].filter(value => !data.get('NM').includes(value));    
                      }  

                    }
                  }
                }
            }
            if(data.has('RW')) {
                let rw = data.get('RW');
                for(let i =0;i < possibleNumberList[rw].length;i++) {
                    if(data.get('IGCL').filter((key1) => {return key1[0] == rw && key1[1] == i}).length == 0) {
                      //console.log(flag +' > RW')  
                      possibleNumberList[rw][i] = possibleNumberList[rw][i].filter(value => !data.get('NM').includes(value));
                    }
                }
            }
            if(data.has('CL')) {
                let cl = data.get('CL');
                for(let i =0;i < possibleNumberList[cl].length;i++) {
                    if(data.get('IGCL').filter((key1) => {return key1[0] == i && key1[1] == cl}).length == 0) {
                      //console.log(flag +' > CL')  
                      possibleNumberList[i][cl] = possibleNumberList[i][cl].filter(value => !data.get('NM').includes(value));
                    }
                }
            }
        } else if(flag == "SF") {

          if(data.has('CL')) {

            let cl = data.get('CL');
            //console.log(data);
            //console.log(cl);
            //return;
            for(let j=0;j < cl.length;j++) {
              for(let i =0;i < possibleNumberList[cl[j]].length;i++) {
                if(data.get('IGCL').filter((key1) => {return key1[0] == i && key1[1] == cl[j]}).length == 0) {
                  //console.log(flag +' > CL')  
                  possibleNumberList[i][cl[j]] = possibleNumberList[i][cl[j]].filter(value => !data.get('NM').includes(value));
                }
              }
            }
           
          }
        }
    }
    function RemoveLoneSingles(possibleNumberList) {
        let kv = [];
        for(let i=0;i< possibleNumberList.length;i++) {
           for(let j=0;j< possibleNumberList[i].length;j++) {
               if(possibleNumberList[i][j].length == 1) {
                     
                    console.log("Row Number: " + i + " Column Number: " + j +" Number: "+possibleNumberList[i][j]);
                   //console.log(possibleNumberList[i][j]);
                   
                   if(!kv.includes(possibleNumberList[i][j][0]))
                        kv.push(possibleNumberList[i][j][0]);
                   //console.log(kv);
                    board[i][j] = String(possibleNumberList[i][j][0]);
                    let bi = getBucketIndex(i,j);
                    //let k = getBucketIndex(oneRemainingRowNumber, oneRemainingColNumber);

                    ToAddIgnoreList("B", possibleNumberList[i][j][0] , bi);
                    ToAddIgnoreList(
                        "RN",
                        possibleNumberList[i][j][0],
                        bi,
                        i,
                        j
                      );
                    let data = new Map();
                    data.set('B',bi);
                    data.set('RW',i);
                    data.set('CL',j);
                    data.set('NM',[possibleNumberList[i][j][0]]);
                    removalFromPossibilityMatrix(possibleNumberList,'HS',data);
               }
           }    
       }
       return kv;
    }  
    function forcefullySetVal(possibleNumberList,val,rw,cl) {
       
        board[rw][cl] = String(val);
       
        let bi = getBucketIndex(rw,cl);
        console.log(rw +'--' + cl + '--' + val + '--' + bi);
        let data = new Map();
        data.set('B',bi);
        data.set('RW',rw);
        data.set('CL',cl);
        data.set('NM',[val]);
        removalFromPossibilityMatrix(possibleNumberList,'HS',data);
        ToAddIgnoreList("B", val , bi);
        ToAddIgnoreList(
            "RN",
            val,
            bi,
            rw,
            cl
        );
    }
    /*
    typeOfWings
      X - XWing
      S - SwordFish
    */
    function findWings(possibleNumberList, typeOfWings){
   
      let possibleNumberPosition = new Map();
      for(let i = 0; i < possibleNumberList.length;i++) {
          for(let j = 0; j < possibleNumberList[i].length;j++) {          
              for(let k = 0; k < possibleNumberList[i][j].length;k++) {    
                 
                  if(possibleNumberPosition.has(possibleNumberList[i][j][k])) {
                      if(possibleNumberPosition.get(possibleNumberList[i][j][k]).has(i)) {
                          possibleNumberPosition.get(possibleNumberList[i][j][k]).get(i).push(j);
                      } else {
                          possibleNumberPosition.get(possibleNumberList[i][j][k]).set(i, [j])
                      }
                  } else {
                      possibleNumberPosition.set(possibleNumberList[i][j][k], new Map([[i, [j]]]));
                  }
                 
              }
          }
      }
      //console.log(possibleNumberPosition)
     
      let clonedMap = new Map(possibleNumberPosition)
       
     
      for (let [key, value] of clonedMap) {
         
        let obj = value;
        if(typeOfWings == 'S') {
          if(obj.size < 3) {
            clonedMap.delete(key)
          } else {
              for (let [k, v] of obj) {
                  if(v.length != 2 && v.length != 3) {
                      clonedMap.get(key).delete(k);
                  }
              }  
          }
        } else {
          for (let [k, v] of obj) {
            if(v.length != 2) {
                clonedMap.get(key).delete(k);
            }
          }
        }
      }  
      //console.log(clonedMap);
      //return;
      for (let [key, value] of clonedMap) {
        let obj = value;
        let arr = Array.from(obj, ([k, v]) => {
              return {[k]: v};
      });
       
        let difference;
       
        for(i = 0; i<arr.length-1;i++) {
            for(j=i+1;j<arr.length;j++ ) {            
                   
              if(typeOfWings == 'S')
              {
                //SwordFish
                for(k=j+1;k<arr.length;k++) {
                  let a4 = Object.values(arr[i])[0].concat(Object.values(arr[j])[0].concat(Object.values(arr[k])[0]));
                  a4 = a4.filter((item,index)=>{
                    return (a4.indexOf(item) == index)
                  });
                  if(a4.length == 3) {
                      console.log("SwordFish >> Number => " + key + " Row Numbers => "
                                  + Object.keys(arr[i])[0] + ' - ' + Object.keys(arr[j])[0] + ' - '
                                  + Object.keys(arr[k])[0] + " Columns => " + Object.values(a4));
                                  let data = new Map();
                                  data.set('CL',Object.values(a4));
                                  data.set('IGCL',[
                                              [
                                                  Object.keys(arr[i])[0],
                                                  Object.values(a4)[0]                                                    
                                              ],
                                              [
                                                Object.keys(arr[i])[0],
                                                Object.values(a4)[1]                                                  
                                              ],
                                              [
                                                Object.keys(arr[i])[0],
                                                Object.values(a4)[2]
                                              ],
                                              [
                                                Object.keys(arr[j])[0],
                                                Object.values(a4)[0]                                                    
                                              ],
                                              [
                                                Object.keys(arr[j])[0],
                                                Object.values(a4)[1]                                                  
                                              ],
                                              [
                                                Object.keys(arr[j])[0],
                                                Object.values(a4)[2]
                                              ],
                                              [
                                                Object.keys(arr[k])[0],
                                                Object.values(a4)[0]                                                    
                                              ],
                                              [
                                                Object.keys(arr[k])[0],
                                                Object.values(a4)[1]                                                  
                                              ],
                                              [
                                                Object.keys(arr[k])[0],
                                                Object.values(a4)[2]
                                              ]
                                            ]);
                              data.set('NM',[
                                              key
                                          ]);    
                              removalFromPossibilityMatrix(possibleNumberList,'SF',data);                    
                  }
                }
              } else {
                let a4 = Object.values(arr[i])[0].concat(Object.values(arr[j])[0]);
                a4 = a4.filter((item,index)=>{
                  return (a4.indexOf(item) == index)
                });
                if(a4.length == 2) {
                    console.log(" X-Wing > Number => " + key + " Row Numbers => "
                        + Object.keys(arr[i])[0] + ' - ' + Object.keys(arr[j])[0] + " Columns => " + Object.values(a4));
                }
              }
            }
        }
      }  
    }
    numberToBeChecked.forEach(logMapElements);
    AddOneMissingNumber();
    numberToBeChecked.clear();

    if (kvArray.length > 0) {
      numberToBeChecked = new Map(kvArray);
      checkNumber();
    } else {
       
        if(pbucket.length == 0)
            pbucket = getPossibleNumberList();
       
        if(pbucket.length > 0) {
           
            findHiddenSDT(pbucket,2,'H','R');
            findHiddenSDT(pbucket,3,'H','R');
            findHiddenSDT(pbucket,2,'H','C');
            findHiddenSDT(pbucket,3,'H','C');
            findHiddenSDT(pbucket,2,'H','B');
            findHiddenSDT(pbucket,3,'H','B');
            findHiddenSDT(pbucket,2,'N','R');
            findHiddenSDT(pbucket,3,'N','R');
            findHiddenSDT(pbucket,2,'N','C');
            findHiddenSDT(pbucket,3,'N','C');
            findHiddenSDT(pbucket,2,'N','B');
            findHiddenSDT(pbucket,3,'N','B');
            findWings(pbucket,'S');
            let kv = [];
            let v1,v2,v3,v4;
            v1 = findHiddenSDT(pbucket,1,'H','C');
            v2 = findHiddenSDT(pbucket,1,'H','R');
            v3 = findHiddenSDT(pbucket,1,'H','B');
            v4 = RemoveLoneSingles(pbucket);
            //console.log(v1.concat(v2).concat(v3));
            let av = v1.concat(v2).concat(v3).concat(v4);
            av = av.filter((item,index)=>{
                           return (av.indexOf(item) == index)
                        });
            for(let i=0;i < av.length;i++) {
                kv.push([av[i], av[i]]);
            }
            console.log('kv');
            console.log(kv);
            if(kv.length > 0 ) {
                numberToBeChecked = new Map(kv);
                checkNumber();
            } else {
               
                //findWings(pbucket,'X');
                //forcefullySetVal(possibleNumberList,val,rw,cl)
               
                if(board[0][6] != "6") {
                    console.log('hhhhhhhhh')
                    forcefullySetVal(pbucket,6,0,6);
                    kv = [];
                    kv.push([6,6]);
                    numberToBeChecked = new Map(kv);
                    checkNumber();
                    console.log('End-1')    
                }
               
               
               
            }
           
        }
        else {
            console.log('End-2')
        }
    }
     
  }
  function ToAddIgnoreList(flag, Num, BucketNo, RowNumber, ColNumber) {
    //console.log(flag +'--'+ Num +'--'+ BucketNo +'--'+ RowNumber +'--'+ ColNumber)
    if (flag == "B") {
      if (
        ignoreBucketNumber.hasOwnProperty(Num) &&
        ignoreBucketNumber[Num].indexOf(BucketNo) == -1
      ) {
        ignoreBucketNumber[Num].push(BucketNo);
      } else ignoreBucketNumber[Num] = [BucketNo];
    } else if (flag == "RN") {
       
      if (ignoreList.has(Num)) {
        if (ignoreList.get(Num).Row.indexOf(parseInt(RowNumber)) == -1)
          ignoreList.get(Num).Row.push(parseInt(RowNumber));
        if (ignoreList.get(Num).Col.indexOf(parseInt(ColNumber)) == -1)
          ignoreList.get(Num).Col.push(parseInt(ColNumber));
      } else {
        ignoreList.set(Num, {
          Row: [parseInt(RowNumber)],
          Col: [parseInt(ColNumber)],
        });
      }
    }
  }
};
